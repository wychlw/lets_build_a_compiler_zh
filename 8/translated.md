# 动手构建一个编译器！

Jack W. Crenshaw, Ph.D.
24 July 1988

# 第八章：一些小小的编程哲学

> 版权许可
> Copyright (C) 1988 Jack W. Crenshaw. 保留一切权力
> 本文由泠妄翻译

## 引入

这章将会是在这个讨论解析和构建编译器的系列中与众不同的一章。这次，我只想和你探讨一会，而不带上任何的代码或实验。幸运的是，这章将会很简短，而后我们便可以带着崭新的精神继续前行。

当我在上大学时，我发现如果我对他的讲义有个比较清楚的认识的话，听他的课将会变得轻松很多。我相信你也有差不多的感受。

所以，我觉得是时候告诉你这系列中之后的章节将会发生什么，以及整体的概念了。我同样也会分享一些通常而言在这件事上有用的技巧。

## 归乡之路

到目前为止，我们已经学到了解析和翻译数学表达式和布尔表达式，并使用关系运算符来将这两种表达式相关联起来。我们同样也学习了如何处理流程控制语句。而在这整个过程中，我们主要使用了以下方法：自顶向下的递归下降解析、BNF语法和直接生成汇编代码。我们也学习到了如何使用单字符标识符的技巧来窥斑知豹。且在上一章中，我们浅尝了以下词法扫描，并展示了如何用一种简单而强大的方法去除单字符标识符的限制。

而在这整个过程中，我都在尝试贯彻KISS准则：保持简单而简洁。我希望你在这个过程中能意识到这一切究竟能有多么简单。的确，编译原理中的有些地方令人望而生畏，但我想这个系列向你展示了，在现实中你完全可以暂时不涉足那些地方。只要你所处理的语言有着恰当的定义，或者你对这种语言语法的定义有着完全的掌控（正如这个系列中的），你完全可以很轻易的就写出它们的BNF语法。而也正如我们所见的，只要有了BNF,你编写解析器的速度就只限制于你的手速了。

而随着我们的编译器一步步成型，他也开始变得越来越大。但其中的每一部分都小而简洁，而其余剩下的部分也差不多是这样的

致辞，我们已经拥有构造一个真实且实用的编译器所需的几乎一切条件。事实上，我们已经拥有了构建一个像Tiny Basic一样强大的语言的编译器所需的一切知识。而在接下的几章中，我们将会完成该语言。

而在这个系列完结之前我们还需要谈论一些东西。它们分别是：
- 带参数和不带参数的函数调用
- 局部变量和全局变量
- 诸如字符或者整数之类的基本类型
- 数组
- 字符串
- 用户自定义类型和结构体
- 树形解析和中间语言
- 优化

我们将会在将来的章节中讲解它们。当我们结束之时，你将会能创建一门自己的语言，并编译和翻译它所写成的程序。

我无法为你设计这样的一门语言，但我可以给你一些建议和个人的简介。我已经在过去的章节中提到一些了，例如你之前见到的，我所喜爱的控制语句的格式。

这些结构将会是我所创造的语言的一部分。现在，我的脑海中有三门语言，而你将会在将来的章节中看到以下两门：

TINY：一个简单但是可用的，结构类似于Tiny BASIC或者Tiny C的语言。它不是很使用，但足够让你写一些能跑得不错的程序。

KISS：一门我创造出来自己使用的语言。KISS被定位一门系统层面的编程语言。它没有很特别的类型会炫酷的数据结构，但它足以满足我对于一门高级语言的需要（可能除了用它来写编译器）。

我也一直以来有个，写一门拥有控制结构和类高级语言赋值语句的类高级语言汇编。事实上，自从我开始学习编译原理之后，这个想法就存在于我的脑海中了。我没开始做这件事的唯一原因是，实现一门类似于KISS这样的，只使用一部分可用指令集的语言会更简单。毕竟，汇编语言可能会非常的奇怪和没有规律可循，创建一个语言到汇编的一对一映射是很困难的。不过……我一直觉得在普通汇编中使用的语法笨笨的……为什么`movq A, B`会比`B = A`更好或更易于翻译呢？

我认为开发这样一个可以让程序员完全访问CPU所提供的指令集和控制CPU，并生成与汇编能提供同等效率，有不用费力去记各种助记词的高级语言会挺有趣。它是可能的吗？我不知道。但我觉得我们真正需要提出的问题大概是“这门新的语言会比汇编更容易编写吗？”，如果不是的话，那我们创造它做什么呢。我认为这是可行的，但是我并不完全确定它的语法该是怎样的。

或许你对此会有一些自己的见解或建议。我很乐意听听它们。

你大概不会惊讶于我已经完成了我们所要讨论的大部分内容。我有个好消息：事情并没有变得更难。你目前所学到的所有技巧已经足够你为一门真正的语言写出一个完整而可工作的编译器。而这不禁让我们有了个有趣的问题：

## 为啥这一切会这么简单？

在着手这个系列之前，我一直觉得编译器就该自然的是个很复杂的电脑程序……而编写它会是个很大的挑战。但是我们目前所做的所有事看起来都很简单，有些甚至是显然的。

在很长的时间中，我都认为这只是因为我们还未触及到它真正硬核的部分。而目前只做了简单的那部分。我承认当我开始编写这系列时，我甚至不确定到什么时候事情会复杂到我们无法用以往的形式来处理。但是现在我已经能告诉你这个问题的答案了。猜猜这一切是为什么吧？

**这里根本没有任何困难的部分！**

而后我认为这是因为我们并没有生成很好的汇编代码。那些一路跟过来的人应该能看出，纵然目前我们生成的代码能运行且具有良好的鲁棒性，它的效率实在是堪忧。你可能会想，消失的复杂性会在我们开始专注于生成不错的代码时出现。

在某种意义上这条倒是真的。在我最初几次尝试进行优化时，我发现我会以一个惊人的速率引入大量的复杂度。但在我仔细的考虑了一些简单的优化之后，它们在**不引入**大量复杂度的同时，生成了质量很不错的代码。

最后，我觉得这只是因为我们学习性质的玩具编译器所具有的固有性质而已。我们并没有尝试写一个能与Borland和Microsoft来进行竞争的编译器。但随着我研究的越来越深入，这个顾虑也消失了。

为了让你清楚的意识到我所想表达的东西，让我在这里再重复一遍：
**使用我们目前所用的技巧，来在我们目前的基础上编写一个代码质量不错的，能运行的编译器，同时不引入过多的复杂度，是完全可行的。**

自从我开始这个系列的编写之后，我收到了你们的一些评论。它们中大多数说出我我自己的心声：“这很简单！为什么教科书让它看起来这么难呢？”好问题。

最近，我又回头看了看原来我的教科书，并买了些新出的教科书读读。每次我都会有同样的感受：这些人把它写的太难了吧。

这里发生了什么？为什么教科书里的显得那么难，但我们的却看起来很简单？我们是比Aho、Ullman、Brinch Hansen和其它所有人都聪明吗？

不太可能。但是对于某些事情的处理上我们采取了不同的方法，而且我越来越欣赏这些方法以及它们是以怎样的角度来简化事情的。除了我们在第一部分所明确指出来的一些捷径，如单字符标识符和控制台I/O，我们还做了一些隐含的假设，和使用了一些人们在之前建造编译器时未使用的一些方法来处理一些部分。事实上，这些方法也确实让我们轻松多了。

那为什么其它人没有使用这些技巧呢？

你需要认识到那些早期编译器编写者所处的环境。他们在容量有限的微型计算机上工作。内存很小，CPU指令集很少，且程序跑在批处理环境下而非交互环境下。而这使得它们做出了一些能大大增加设计复杂度的关键性觉此。直到最近我才意识到有多少经典的编译器设计都是被有限的硬件所逼迫的结果。

而哪怕目前这些限制都已经消失了，毕竟他们被教到编译器就该这么写，人们也倾向于用同样的方法来编写编译器。

下面是我认为在过去引入了复杂度的一些设计：
- 有限的内存导致了多趟编译
  
  我最近刚读了《Brinch  Hansen  on  Pascal   Compilers》（顺便提一句，很不错的一本书）。他为个人电脑编写了一个Pascal编译器，可他是在1981年用一台只有64K的电脑来进行这项工作的，于是他所做的几乎每个设计都是为了让编译器能被放进内存中去。为此，他的程序有三趟编译，而其中一次便是词法扫描。他根本不可能去使用一些例如上一章讲到的分布式扫描器的技巧，因为程序架构根本不允许他这么做。他同样得创造不止一种，而是两种中间语言，来在不同的阶段间进行交流。

  所有的早期编译器编写者都面临着这个困境：把编译器分成足够多的部分以让它们能被放在内存中。当你进行多趟编译时，你不得不创造一种数据结构来在存储一趟给下一趟所需提供的信息。而这不仅增加了复杂性，也导致了编译器的设计向着一个特定的方向行进。在Lee所编写的书《The  Anatomy  of a Compiler》中提到了为IBM1401型电脑所编写的一个FORTRAN编译器。它有着超过63趟的编译过程！显然一个需要把编译分为不同阶段的设计将会主导整个编译器设计。

  即便目前内存已经很充足了，由于人们熟悉这种技巧，他们会倾向于使用同样得方法。直到Turbo Pascal出现之后，我们才意识到当你以一个不同的视角来看一个编译器，它能有多简单。

- 批处理

  在早些时候，批处理程序是唯一的选择……当时还没有交互式计算这个概念。直到今天，编译器本质上依然运行在批处理模式下。

  在主流编译器和大多数小型编译器中，大量的精力都被花在了错误处理上……这能占到一个编译器的30%到40%，并彻底主导整个设计。这个概念主要指避免在遇到了第一个错误时就完全停机，而是为了尽可能的找出整个程序的更多问题而不计代价的继续运行。

  这一切都可以追溯到周转时间以小时或天为单位来衡量的大型机的时代，因此从每次运行中尽可能的榨取每一滴信息是非常重要的。

  在这个系列中，我一直在小心的避免错误恢复，因此我们的编译器会简单的在遇到第一个错误时停机并报错。我承认这主要是因为我想用简单的方法，并让事情保持的简单一些。不过，这种由Borland在Turbo Pascal中首创的方法也有着诸多益处。这种方法除了能保持编译器很简单外，它也能很好的融入交互式系统之中。当编译速度很快，且你有一个向像Borland的，能停在第一个发生的错误的编辑器时，直接停在那并在修复了错误之后重新开始变得很合理了。

- 对大程序的支持

  早期的编译器都被设计为能支持大程序，也就是考虑无限大的那种。在那段时间，这并没有太大可选择的余地：库文件和分开编译都还是未来的技术。这一假设同样带来了多趟编译和过程中为保存信息设计的中间文件。

  Brinch Hansen的最终目标是编译器应当能编译它自己。由于他有限的内存，这同样逼迫他去使用多趟编译的技术。他的编译器在内存中的代码应尽可能的少，这样必要的表和其它数据结构才能被放进内存里。

  因为这对我们还没有必要，我并没有在之前说明这一点……毕竟无论怎样，我们总是以流的形式来读取和写入数据。但我必须要声明一下，在我的计划中，在一个生产环境的编译器里，源数据和对象数据都应像早期的Turbo Pascal那样存在于编译器的内存中。这就是为什么尽管`getChar`和`emit`很小，我依然一直将它们分开为单独的函数。这样，将它们更改为从内存读写的代码会更容易。

- 对性能的强调
  
  John Backus曾表示过，当他和同事最初开发FORTRAN的编译器时，它们**知道**必须能让它产生很紧凑的代码。当时，人们因为效率青睐于汇编语言而对高级语言持有反对态度。如果FORTRAN不能生产与汇编直接编写的一样好的代码的话，那么用户就不会使用它。根据记载，在代码质量方面，FORTRAN编译器是有史以来最好的编译器。但它**非常**复杂！

  如今的我们有着足够的CPU性能和内存空间，代码效率将不会再成为一个问题。通过简单的忽略这个问题，我们的确能让一切保持简单。讽刺的是，正如我说过的，我找到了一些不需要增加很多复杂性就能添加到我们基本的编译器结构中的优化。因此，在此处我们可以鱼与熊掌兼得：到最后，无论如何我们都能获得还不错的代码质量。

- 有限的指令集

  早期计算机的指令集非常原始。很多诸如堆栈操作和间接寻址这样我们认为理所应当的指令，在实现上都需要经过很多困难。

  例如：在大多数编译器的设计中，都有个叫“常量池”的数据结构。通常而言，编译器会识别出程序中的所有常量，并将它们放到同一个数据结构中。所有对常量的引用都是从这个池中间接实现的。在编译结束时，编译器发出命令划分空间并初始化常量池。

  我们还完全没有遇到这个问题。当我们想加载一个常量时，我们直接在一行代码中照做就是了，例如

  `movq $3, %rax`

  特别是在像8086这样，可以分开存储数据和代码的机器上，我们对常量池的使用还是有些可以谈谈的内容。不过，这个东西回报很小但会增加大量的复杂度。

  当然，没有堆栈的话我们就会彻底迷失了。在微观上，函数调用和数据的临时存储都严重依赖于堆栈，且我们还需要在简化对表达式的解析时大量的使用它。

- 对通用性的渴望

  在典型的编译器书籍中的大部分内容都会涉及到我们根本没有提及过的问题……如语法自动翻译或LALR解析并的生成。这不仅是因为作者想给你留校一些深刻的印象。他们都有充分、实际的理由而存在。 

  我们一直专注于使用递归下降解析器来解析具有确定性，也就是由于没有歧义而可以采用一个前瞻字符而进行解析，的语法。在之前，我并没有过多的讨论这个语法上的限制，但这却是只是所有可能语法的一个很小的子集而已。事实上，这个世界上有无数的语法无法使用这个技术来进行解析。LR（自顶向上解析）是一种可以用来处理我们无法解析的语法的更强大的技术。

  在编译原理中，知道如何处理其它那些语法并将其转化为更容易处理的语法，是很重要的。例如，很多（但不是全部）含糊不清的语法都能被转换到含义清晰的语法。虽然，这些转换的语法可能并不是显然的，且需要很多人投入很多时间来开发一种自动进行转换的方法。

  而在实践中，这些文帝变得很不重要。无论怎样，现代的语法都倾向于以一种易于解析的方法来定义。这也是设计Pascal语言时的一个关键想法。的确，有些病态的语法会很难写出它们的BNF，但在现实中最好的做法可能是直接避免这些语法的出现！

  当然，在我们的离职中，我们偷偷的让语法随着我们的进程而发展，所以我们并未陷入如此的困境。你可能并不总是能有权力这么做。不过，只要保持小心，你应该能在不求助语法自动翻译的条件下保持解析的简单。

我们在这个系列中用了一种非常不同的做法。我们从完全空白开始，逐渐开发出了适合我们环境，也就是具有充足CPU资源和内存的个人PC，的技术。我们限制自己使用合理且易于解析的语法，我们使用了高级的CPU指令集，且我们没有太考虑性能。这就是为什么我们感觉这一切很简单。

这是否意味着我们注定只能永远编写一个玩具编译器呢？不，我不这么认为。正如我所说，我们可以在不改变编译器结构的条件下加入一些优化。如果我们想要处理大文件，我们总可以添加一个文件缓存来实现这个功能。这些事情并不会影响我们编译器的总体架构。

且我认为这是个很关键的罂粟。正因我们从小而受限的情况开始，我们才能关注于最适合这个任务的编译器结构。由于这个结构很自然的适合用于处理这个问题，这几乎意味着这个结构是简单而透明的。增加更多的能力并不需要改变最基本的结构。我们只需要简单的进行诸如扩展文件结构或者增加优化层就行了。我的想法是，当资源很紧张时，人们并不会去寻求解决当前问题的最佳结构，而是将最终采用的结构人为的扭曲，以便于让它在这些条件下进行工作。

## 结论

无论如何，这就是我对我们是怎样保持事情简单的一些小小的猜测。我们没有尝试强迫它的结构满足某些经典的模式，而是从简单的条件开始，让它自然的发展。

我们将会在此基础上继续努力。我已经给了你我们将会在未来几章中所覆盖的领域的列表。在学习这几章之后，你应该能简单的搭建适用于任何场景中的，完整而能工作的编译器。而如果你想搭建一个能产生高质量代码的编译器，这同样是可以做到的。

对那些想看到更多解析器代码而恼火的人，我为我的离题道歉。我直接觉得你应该更客观的看待这些事情。我们将会在下一章中回到教程的主线任务上来。

目前，我们只看过了编译器的一个个部分，虽然我们已经拥有了编译一门完整语言所需的所有技巧，我们还没有将它们组合起来使用过。这将会是我们将来两章所需要做的事。之后我们将会进入我在本章开始列出的新主题之中。

下次见:)

> 版权许可
> Copyright (C) 1988 Jack W. Crenshaw. 保留一切权力
> 本文由泠妄翻译