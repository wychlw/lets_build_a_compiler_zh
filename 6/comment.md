# 关于对True和False表示的选择
在原作者所使用的68000CPU中，与这里类似的SETcc指令并不是**把寄存器设为1**，而是**设置为FFFF**（16进制的时代哦）。而这也导致，在原作者看起来非常合理的-1,在我们看来总是怪怪的。

在（几乎所有）现代一些的架构中，它们都会设置成1而非-1。

如x86中SETcc reg会当真时把reg设置为1。你可能也注意到了，我们会先设置一个8位的寄存器AL，再将其零扩展到64位。这是因为SETcc只能设置一个byte…或许可以去问问2023年还在支持x86-16和使用16位系统的人为什么……？

而在RV中则会直接将比较结果放到寄存器里。挺方便的w

而对于所说的NOT直接取反…其实我们可以test然后setz，所以并不是什么大问题。

不过这里我们先忠于原作者的-1，然后兜个圈子吧。不过，其实你可以试试自己改改看，变成1呢？w

祝你的旅途愉快喵～😺