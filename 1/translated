			动手构建一个编译器！
			Jack W. Crenshaw, Ph.D.
			24 July 1988
第一部分 简介

版权许可：
Copyright (C) 1988 Jack W. Crenshaw. 保留一切权利.
本文由梓瑶翻译并重写为 Lua 代码

简介

这一系列文章是以开发语言解析器和编译器为主题的教程。在结束这趟旅程之前，
我们会涉足编译器构建的每一个方面，设计一门全新的编程语言，并且构建一个
完整的编译器。

尽管从所学的专业上讲，我并不是一个计算机科学家（我的博士后学位涉及的是
不同的领域，物理），但数年来我一直对编译器很感兴趣。我买过这个领域的几
乎所有书籍，试着理解其中的内容，并且毫不介意告诉你这么做确实是个漫长的
过程。编译领域的文献是写给那些计算机科学专业的人的，对于剩下的我们来讲
就如同天书。但是这些年中我开始慢慢理解其中的一点内容了，转折点就是自己
试着动手在计算机上做实验的时候。现在我就打算向你分享我学到的这些东西。
读完这一系列文章不会让你成为一个计算机科学家，也不会让你对编译原理的那
些大部头理论了如指掌。我倾向于完全忽略编译原理中较为理论化的方面，你将
会学到的就是构建一个实用的编译系统时能用上的方方面面。

这是一系列“做中学”的文章，其中我会在计算机上做一些实验，而你要做的就是
跟着我重复我做过的，然后搭配一点你自己想要做的。我会在一台 PC 上用
Turbo Pascal 4.0 编程，并且文章里面也会间断着插入一些 Turbo Pascal 代
码。这些都是复制下来就能跑的代码，你要做的就是拷贝到你的计算机中然后让
它跑起来。没有 Turbo 的话，你接下来学习这些东西的工作原理的时候就会受
到极大限制，我建议你买一份。无论如何，这是个蛮不错的产品，用在其他方面
也很合适！

（译者注: 本文翻译版已经用 Lua 代替了 Turbo Pascal，关于运行环境的细节
请参考 /1/comment）

有一些关于编译器的文章只是给你展示了一些例子，或者给你展示一个成品的编
译器（比如 Small-C），这些你都可以直接复制下来，不经理解其原理就直接使
用，而我想做的要比这种更进一步。我希望能教给你我们是如何实现我们的目的
的，这样你就可以脱离我的内容做自己的改进，而不是只会照葫芦画瓢地复刻。

这确实算个宏大的承诺，不可能几句话就写完的。我希望在接下来的一系列文章
中做到这一点。每一篇文章都会涉及编译理论的一个方面，同时之间又基本独立
。如果你在某个时间点感兴趣的只是一个方面，你只需要看对应的一篇文章就可
以了。每一篇文章都会在写完时尽快发布，这样的话你在觉得学得够多了之前
能不得不等一段时间。要有耐心。

（译者注：翻译工作也一样，要有耐心 :)）

大部分编译原理的论著都包括一些我们不会提到的基础知识，典型的流程大概是
这样：

 o 简介，描述编译器是什么

 o 一两章节花在了语法描述上，使用 Bacakus-Naur 形式（BNF 文法）

 o 一两章节讲词法扫描，重点在确定的有穷自动机和非确定的有穷自动机上

 o 几章节研究解析理论，从自顶向下的递归下降解析器开始，以 LALR 解析器
   结束

 o 一章节描述中间语言，重点放在 P 代码以及一些与逆波兰表示相似的技术
   上

 o 许多章节讲解不同的处理子例程，参数传递和类型定义等等的方法

 o 一章节面向代码生成，一般以一个假设的指令集较为简单的 CPU 为例。大部
   分读者都不会读到这里（实际上大部分大学课程也学不到）

 o 最终的一两章讲解优化。这一部分基本也没人看。

我在这一系列中将会采取一个非常不同的方案。开始时我不会在做选择上花太多
时间，而是转而提供一个能工作的方法。如果你想要实验一下其他的选项...我
鼓励你这么做...但是我还是会坚守我熟知的方法。同时我也会跳过大部分让人
打瞌睡的理论内容。不要理解错我的意思：我并没有轻视理论的重要性，它在解
决一门给定编程语言的较为棘手的一些部分的时候非常重要。但是我相信的是把
重要的事情放在第一位。我们现在是在学习编译技术中 95% 的内容，这些不需
要很多理论就能解决了。

我只会讨论一种解析方案：自顶向下，递归下降式的解析，也是唯一能优雅地手
写一个编译器的方法。剩下的方案只在你使用 YACC 这类工具时才有用，并且也
根本不考虑最终产品到底消耗了多少内存。

我也从 Ron Cain，Small C 的原作者的作品中借来了一点内容。其他大部分编
译器作者都由于历史原因使用了类似 P 代码的中间语言同时把编译器分为两部
分（一个输出 P 代码的前端，一个处理 P 代码并且生成可执行文件的后端），
但 Ron 向我们证明了，编写一个直接生成汇编语言表示的可执行文件的编译器
是很直截了当的做法。这样生成的代码不会是世界上最紧凑的....生成优化良
好的代码是一项困难地多的工作。但是这样做确实可行，并且效果相当不错。我
不希望这么做会给你留下我们最终的产品一文不值的印象，我倾向于向你展示如
何使用一些优化来增强编译器。

最后，我会用一些我已经发现有帮助的技巧，来在避免过度关注实现细节的同时
理解正在发生的一切。其中首先就是在早期的设计中使用单个字符不含空格的词
法单元。很明显如果我能让解析器认识并处理 I-T-L，那我也可以让它对
IF-THEN-ELSE 做一样的事情。在第二课中，我会向你展示扩展解析器使其能够处
理任意长度的词法单元是多么简单。另一个技巧是完全忽略输入输出，我觉得如
果我能从键盘读取源代码并把输出打印在屏幕上，我也可以从硬盘读取再写入相
应的输出。经验标明把一个工作良好的翻译器重定向 IO 操作到文件是个很直白
的工作。最后一个技巧是我不会试着去做错误纠正或者错误回复。我们构建的编
译器能够识别错误而不会崩溃，但是它就会在第一处错误停止解析...就像
Turbo 一样。接下来的阅读过程中你会看到其他的技巧，大部分在任何讲解编译
的书籍中都找不到，但是这些确实有效。

我得在风格和效率上说几句。正如你将要看到的，我倾向于把程序拆分成非常小
而容易理解的片段来编写。我们要编写的函数没有一个会超过 15-20 行。我是
KISS 原则的热烈拥护者，如果有可能的简单方法，我从来不会去用复杂棘手的
方法解决问题。性能不好？可能是这样的，但是你也会对这样的结果感到满意了
。正如 Brain Kernighan 说过的，先让它跑起来，再让它跑得快一点。之后如
果你想要回来优化我们编译器中的代码，你当然可以这么做，我们的代码会非常
容易理解。当然，我建议在我们的编译器已经实现了所有你想要的功能之后再进
行优化。

我习惯在真正发现要用到它时才去编写这部分代码。把所有之后所有的可能性都
考虑在内会把你逼疯的，何况基本上我们都猜不对要用到什么。在有全屏式编辑
器和快速的编译器的现代，我会在需要更多功能时毫不犹豫地修改这个模块。那
时候我再写我需要的东西。

最后一条：我们不会捣鼓 P 代码或者什么假设的 CPU，这是我们坚持的原则之
一。相反地，我们会从产生能运行的二进制代码开始，至少也要是汇编源代码的
形式。尽管这样，你可能不太会喜欢本书原作者用的汇编语言... 68000 的指令
集，作者的系统用的就是（译者注：要知道这是上世纪的计算机）。没关系，这
里我们已经换成了 x86-64 汇编。当然，我觉得你很快就会发现翻译到其他的架
构，比如 RISC-V，也很容易做到。

基础框架

每个程序都有些基本的框架... I/O 例程，错误消息例程这些。我们要开发的编
译器也毫不例外。不过我已经尽可能把这类内容减少了，这样我们可以把精力集
中在重要的内容上而不会被自己绕晕了。下面以最少的代码量实现了这些事情，
包括一些 I/O 例程，一个错误处理例程和一个空的主程序骨架。我就把它叫做
我们的基础框架了。当我们开发其它的内容的时候，我们会把它添加到基础框架
中，并在需要的时候调用它。拷贝一份基础框架，保存好，我们之后可不止要用
它一次。

组织解析器扫描的方式有很多种，POSIX 标准的代码会用 read() 这一类。很幸
运，我在这里用了一个全局的向前看字符。初始化例程的一部分（也是现在唯一
的一部分）会通过从输入流读取一个字符来给整个系统“点火”。这边不需要什么
C 语言的其他技术，每一次对 get_char() 的成功调用都会返回一个新的字符。


local io		= require "io";
local string		= require "string";
local math		= require "math";

local look = '';		-- 向前看字符

--[[ 从输入读取新的字符 ]]
local function getChar()
	look = io.read(1);
end

--[[ 报告期望的内容 ]]
local function expected(s)
	error(s .. " expected");
end

--[[ 匹配一个特定的字符 ]]
local function match(c)
	if look == c
	then
		getChar();
	else
		expected(c)
	end
end

--[[
--	识别是否是字母
--	string.match() 匹配一个字符模式，其中 %a 模式仅匹配大小写字符，如果
--	匹配失败则返回 nil。Lua 中 nil 和 false 都作为逻辑假处理
--]]
local function isAlpha(c)
	return string.match(c,"%a");
end

--[[ 识别是否是数字。相对的，%d 能够匹配一位数字 ]]
local function isDigit(c)
	return string.match(c,"%d");
end

--[[ 读取一个标识符 ]]
local function getName()
	if not isAlpha(look)
	then
		expected("name");
	end
	local name = look;
	getChar();
	return name;
end

--[[ 读取一个数字 ]]
local function getNum()
	if not isDigit(look)
	then
		expected("integer");
	end
	local num = look;
	getChar();
	return num;
end

--[[ 输出一个制表符和字符串 ]]
local function emit(s)
	io.write("\t" .. s);
end

--[[ 输出制表符和指定的字符串，然后换行]]
local function emitLine(s)
	emit(s .. "\n");
end

--[[ 初始化 ]]
local function init()
	getChar();
end

-- 主程序从这里开始

init();

这篇简介中就是这些内容了。把代码拷贝到一个文件里，用 Lua 解释器运行一
下确保一切正常，然后开始看第一课吧。我们要学习表达式解析了。


			版权声明
Copyright (c) 1988 Jack W. Crenshaw. 保留一切权利。
本文由梓瑶翻译并重写为 Lua 代码
